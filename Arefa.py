# -*- coding: utf-8 -*-
"""Untitled36.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YYEnqhFGyFIRk49vHA5BXoa-CsMl0bJC
"""

def draw_player_car():

    glPushMatrix()
    glTranslatef(player_x, player_y, player_z)

    # Main Chassis

    glColor3f(0.9, 0.1, 0.1)  # Sporty red color
    glPushMatrix()
    glScalef(0.8, 1.6, 0.3)
    glutSolidCube(50)
    glPopMatrix()

    # Cabin
    glColor3f(0.15, 0.15, 0.2)
    glPushMatrix()
    glTranslatef(0, -10, 18)
    glScalef(0.6, 0.7, 0.5)
    glutSolidCube(40)
    glPopMatrix()

    # Rear Spoiler
    glColor3f(0.1, 0.1, 0.1)

    glPushMatrix()
    glTranslatef(0, -65, 22)
    glScalef(1.0, 0.2, 0.05)
    glutSolidCube(40)
    glPopMatrix()


    # Spoiler Supports
    glPushMatrix()
    glTranslatef(-15, -62, 15)
    glScalef(0.1, 0.1, 0.4)
    glutSolidCube(20)
    glPopMatrix()
    glPushMatrix()
    glTranslatef(15, -62, 15)
    glScalef(0.1, 0.1, 0.4)
    glutSolidCube(20)
    glPopMatrix()

    # Wheels
    glColor3f(0.1, 0.1, 0.1)
    wheel_radius = 8

    wheel_positions = [
        (22, 45, -5),
        (-22, 45, -5),
        (22, -50, -5),
        (-22, -50, -5)
    ]
    for x, y, z in wheel_positions:
        glPushMatrix()
        glTranslatef(x, y, z)
        gluSphere(gluNewQuadric(), wheel_radius, 10, 10)
        glPopMatrix()


    # Headlights (Yellow)
    glColor3f(1, 1, 0)
    glPushMatrix()
    glTranslatef(15, 65, 2)
    glutSolidCube(6)
    glPopMatrix()
    glPushMatrix()
    glTranslatef(-15, 65, 2)
    glutSolidCube(6)
    glPopMatrix()

    # Taillights (Bright Red)
    glColor3f(1, 0, 0)
    glPushMatrix()
    glTranslatef(17, -67, 8)
    glutSolidCube(5)
    glPopMatrix()
    glPushMatrix()
    glTranslatef(-17, -67, 8)
    glutSolidCube(5)
    glPopMatrix()

    # Gun on top
    glColor3f(0.5, 0.5, 0.5)
    glPushMatrix()
    glTranslatef(0, -5, 30)
    glRotatef(-90, 1, 0, 0)
    gluCylinder(gluNewQuadric(), 3, 2, 25, 8, 1)
    glPopMatrix()

    # Nitro flames
    if nitro_active:
        glColor3f(0.2, 0.6, 1.0)

        glPushMatrix()
        glTranslatef(12, -75, 2) #
        glRotatef(90, 1, 0, 0)
        gluCylinder(gluNewQuadric(), 5, 0, 20, 8, 1)
        glPopMatrix()
        glPushMatrix()
        glTranslatef(-12, -75, 2)
        glRotatef(90, 1, 0, 0)
        gluCylinder(gluNewQuadric(), 5, 0, 20, 8, 1)
        glPopMatrix()

    glPopMatrix()

def draw_road():
    glPushMatrix()

    # Main road surface
    glColor3f(0.3, 0.3, 0.3)
    glBegin(GL_QUADS)
    glVertex3f(-ROAD_WIDTH/2, -ROAD_LENGTH, 0)
    glVertex3f(ROAD_WIDTH/2, -ROAD_LENGTH, 0)
    glVertex3f(ROAD_WIDTH/2, ROAD_LENGTH, 0)
    glVertex3f(-ROAD_WIDTH/2, ROAD_LENGTH, 0)
    glEnd()

    # Lane dividers
    glColor3f(1, 1, 1)
    for lane_x in [-200, -100, 0, 100, 200]:
        for y in range(-ROAD_LENGTH, ROAD_LENGTH, 100):
            offset = int(road_offset) % 200
            glBegin(GL_QUADS)
            glVertex3f(lane_x-2, y - offset, 0.5)
            glVertex3f(lane_x+2, y - offset, 0.5)
            glVertex3f(lane_x+2, y + 50 - offset, 0.5)
            glVertex3f(lane_x-2, y + 50 - offset, 0.5)
            glEnd()

    # Road edges
    glColor3f(1, 1, 0)
    # Left edge

    glBegin(GL_QUADS)
    glVertex3f(-ROAD_WIDTH/2-3, -ROAD_LENGTH, 0.5)
    glVertex3f(-ROAD_WIDTH/2+3, -ROAD_LENGTH, 0.5)
    glVertex3f(-ROAD_WIDTH/2+3, ROAD_LENGTH, 0.5)
    glVertex3f(-ROAD_WIDTH/2-3, ROAD_LENGTH, 0.5)
    glEnd()
    # Right edge
    glBegin(GL_QUADS)
    glVertex3f(ROAD_WIDTH/2-3, -ROAD_LENGTH, 0.5)
    glVertex3f(ROAD_WIDTH/2+3, -ROAD_LENGTH, 0.5)
    glVertex3f(ROAD_WIDTH/2+3, ROAD_LENGTH, 0.5)
    glVertex3f(ROAD_WIDTH/2-3, ROAD_LENGTH, 0.5)
    glEnd()

    # Side barriers using glutSolidCube
    glColor3f(0.5, 0.5, 0.5)
    for side in [-ROAD_WIDTH/2 - 20, ROAD_WIDTH/2 + 20]:
        glPushMatrix()
        glTranslatef(side, 0, 25)
        glutSolidCube(50)  # Barrier
        glPopMatrix()

    glPopMatrix()

# pop-up messages
def draw_pop_ups():
    for i, msg in enumerate(pop_up_messages):
        # Display messages stacked in the middle of the screen
        draw_text(420, 450 - i * 30, msg["text"], GLUT_BITMAP_HELVETICA_18)

def draw_hud():
    # Health bar using TEMPLATE approach
    draw_text(10, 770, f"Health: {player_health}/{player_max_health}")

    # Health bar visualization
    health_bar = "[" + "=" * (player_health // 5) + "-" * ((100 - player_health) // 5) + "]"
    draw_text(10, 750, health_bar)

    # Game stats
    draw_text(10, 730, f"Score: {player_score}")
    draw_text(10, 710, f"Level: {current_level}/3")
    draw_text(10, 690, f"Missiles: {missile_count}/25")
    draw_text(10, 670, f"Nitro: {nitro_count}/{max_nitro}")
    draw_text(10, 650, f"Cars Dodged: {cars_dodged}/{level_configs[current_level]['cars_to_dodge']}")

    # Level timer
    effective_elapsed_time = (time.time() - level_start_time) - total_paused_time
    remaining = level_duration - effective_elapsed_time
    draw_text(10, 630, f"Time: {max(0, remaining):.1f}s")

    # Speed indicator
    effective_speed = player_speed + level_configs[current_level]["player_speed_boost"]
    draw_text(10, 610, f"Speed: {effective_speed}")

    # Controls
    draw_text(800, 770, "Controls:")
    draw_text(800, 750, "A/D - Switch lanes")
    draw_text(800, 730, "Space - Shoot")
    draw_text(800, 710, "N - Nitro")
    draw_text(800, 690, "P - Pause")
    draw_text(800, 670, f"C - Camera: {camera_mode}")

    # Messages
    if game_over:
        draw_text(400, 400, "GAME OVER!", GLUT_BITMAP_HELVETICA_18)
        draw_text(380, 360, f"Final Score: {player_score}")
        # Display High Score on Game Over
        draw_text(380, 340, f"High Score: {high_score}")
        draw_text(350, 300, "Press R to Restart")
    elif game_won:
        draw_text(380, 400, "VICTORY!", GLUT_BITMAP_HELVETICA_18)
        draw_text(360, 360, f"Final Score: {player_score}")
        # Display High Score on Win
        draw_text(360, 340, f"High Score: {high_score}")
        draw_text(350, 300, "Press R to Restart")
    elif paused:
        draw_text(450, 400, "PAUSED", GLUT_BITMAP_HELVETICA_18)

def setupCamera():

    glMatrixMode(GL_PROJECTION)
    glLoadIdentity()
    # (field of view, aspect ratio, near clip, far clip)
    gluPerspective(fovY, 1.25, 0.1, 1500)
    glMatrixMode(GL_MODELVIEW)
    glLoadIdentity()


    x, y, z = camera_pos

    if camera_mode == "third_person":

        gluLookAt(x, y, z, 0, player_y + 100, player_z, 0, 0, 1)
    else:
        # First person view -
        gluLookAt(player_x, player_y + 20, player_z + 30,
                  player_x, player_y + 200, player_z,      #the road
                  0, 0, 1)

def spawn_enemy_car():
    global spawn_counter
    max_enemies = level_configs[current_level]["max_enemies_on_screen"]
    min_enemies = level_configs[current_level]["min_enemies_on_screen"]

    force_spawn = len(enemy_cars) < min_enemies

    if len(enemy_cars) >= max_enemies and not force_spawn:
        return

    available_lanes = list(range(6))


    if not force_spawn:
        for enemy in enemy_cars:
            if enemy.y > 500:
                if enemy.lane in available_lanes:
                    available_lanes.remove(enemy.lane)


    if not available_lanes:
        available_lanes = list(range(6))
        if current_lane in available_lanes:
            available_lanes.remove(current_lane)

    if available_lanes:

        spawn_counter += 1
        lane_index = spawn_counter % len(available_lanes)
        lane = available_lanes[lane_index]
        enemy_cars.append(EnemyCar(lane))

def spawn_boss():
    global boss_car, spawn_counter
    if not boss_car:

        available_lanes = [i for i in range(6) if i != current_lane]
        spawn_counter += 1
        boss_lane = available_lanes[spawn_counter % len(available_lanes)]
        boss_car = EnemyCar(boss_lane, is_boss=True)
        enemy_cars.append(boss_car)

def spawn_powerup():
    global spawn_counter

    available_lanes = [i for i in range(6) if i != current_lane]
    spawn_counter += 1
    lane = available_lanes[spawn_counter % len(available_lanes)]
    type = "health" if spawn_counter % 2 == 0 else "nitro"
    powerups.append(PowerUp(lane, type))

#Function to spawn red obstacles
def spawn_red_obstacle():
    global spawn_counter
    available_lanes = [i for i in range(6) if i != current_lane]
    if available_lanes:
        spawn_counter += 1
        lane_index = spawn_counter % len(available_lanes)
        lane = available_lanes[lane_index]
        red_obstacles.append(RedObstacle(lane))

def update_missiles(dt):
    global missiles, enemy_cars, player_score, player_health, boss_car
    missiles_to_remove = []

    for missile in missiles:
        missile['y'] += missile['vy'] * dt

        if missile['y'] > 1000 or missile['y'] < -500:
            missiles_to_remove.append(missile)
            continue

        if missile['owner'] == 'player':
            for enemy in enemy_cars[:]:
                if abs(missile['x'] - enemy.x) < 40 and abs(missile['y'] - enemy.y) < 60:
                    enemy.health -= 24
                    if enemy.health <= 0:
                        explosions.append(Explosion(enemy.x, enemy.y, enemy.z))
                        player_score += 500 if enemy.is_boss else 100
                        if enemy in enemy_cars:
                            enemy_cars.remove(enemy)
                        if enemy.is_boss:
                            boss_car = None
                        # NEW --- Add pop-up message
                        add_pop_up("Enemy Destroyed!")
                    missiles_to_remove.append(missile)
                    break
        else:  # enemy missile
            if abs(missile['x'] - player_x) < 30 and abs(missile['y'] - player_y) < 50:
                player_health -= missile['damage']
                missiles_to_remove.append(missile)

    for missile in missiles_to_remove:
        if missile in missiles:
            missiles.remove(missile)

def check_collisions():
    global player_health, cars_dodged, nitro_count, missile_count, game_over, player_score
    enemies_to_remove = []
    powerups_to_remove = []

    # Enemy car collisions
    for enemy in enemy_cars:
        if abs(enemy.x - player_x) < 50 and abs(enemy.y - player_y) < 80:
            damage = level_configs[current_level]["boss_damage"] if enemy.is_boss else level_configs[current_level]["enemy_damage"]
            player_health -= damage
            explosions.append(Explosion(enemy.x, enemy.y, enemy.z))
            enemies_to_remove.append(enemy)
            if player_health <= 0:
                player_health = 0
                game_over = True
                add_pop_up("Game Over!")
                save_high_score(player_score)
        elif enemy.y < player_y - 100:
            enemies_to_remove.append(enemy)
            cars_dodged += 1
            player_score += 50

    for enemy in enemies_to_remove:
        if enemy in enemy_cars:
            enemy_cars.remove(enemy)

    # Power-up collisions
    for powerup in powerups:
        if abs(powerup.x - player_x) < 40 and abs(powerup.y - player_y) < 60:
            if powerup.type == "health":
                player_health = min(player_health + 30, player_max_health)

                add_pop_up("Health Restored!")
            elif powerup.type == "nitro":
                nitro_count = min(nitro_count + 1, max_nitro)
            powerups_to_remove.append(powerup)
            player_score += 25
        elif powerup.y < -500:
            powerups_to_remove.append(powerup)

    for powerup in powerups_to_remove:
        if powerup in powerups:
            powerups.remove(powerup)

    #Red Obstacle collisions
    obstacles_to_remove = []
    for obstacle in red_obstacles:
        if abs(obstacle.x - player_x) < 40 and abs(obstacle.y - player_y) < 40:
            player_health = 0
            game_over = True
            add_pop_up("Game Over!")
            save_high_score(player_score)
            explosions.append(Explosion(player_x, player_y, player_z))
            obstacles_to_remove.append(obstacle)
        elif obstacle.y < -500:
            obstacles_to_remove.append(obstacle)

    for obstacle in obstacles_to_remove:
        if obstacle in red_obstacles:
            red_obstacles.remove(obstacle)

def check_level_completion():
    global current_level, game_won, game_over, level_start_time


    elapsed = (time.time() - level_start_time) - total_paused_time
    cars_target = level_configs[current_level]["cars_to_dodge"]

    if current_level < 3:
        if cars_dodged >= cars_target and elapsed >= level_duration:
            current_level += 1
            if current_level > 3:
                game_won = True
                save_high_score(player_score)
            else:
                reset_level()
        elif elapsed >= level_duration * 1.3 and cars_dodged < cars_target:
            game_over = True
            save_high_score(player_score)
    else:
        boss_defeated = boss_car is None or boss_car not in enemy_cars
        if boss_defeated and cars_dodged >= cars_target and elapsed >= level_duration:
            game_won = True
            save_high_score(player_score)
        elif elapsed >= level_duration * 1.5 and not boss_defeated:
            game_over = True
            save_high_score(player_score)

def reset_level():
    global level_start_time, cars_dodged, enemy_cars, missiles, powerups, red_obstacles
    global boss_car, missile_count, player_speed, total_paused_time

    level_start_time = time.time()
    total_paused_time = 0
    cars_dodged = 0
    enemy_cars.clear()
    missiles.clear()
    powerups.clear()
    red_obstacles.clear()
    missile_count = 25
    boss_car = None

    player_speed = 300 + level_configs[current_level]["player_speed_boost"]

    min_enemies = level_configs[current_level]["min_enemies_on_screen"]
    # Distribute enemies across different lanes
    for i in range(min_enemies):
        lane = i % 6
        enemy = EnemyCar(lane)
        enemy.y = 400 + (i * 200)
        enemy_cars.append(enemy)

    if current_level == 3:
        spawn_boss()
